<?xml version="1.0"?>
<doc>
    <assembly>
        <name>MarcusW.VncClient</name>
    </assembly>
    <members>
        <member name="T:MarcusW.VncClient.Color">
            <summary>
            Represents a single RGB color value.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Color.R">
            <summary>
            Gets the red value.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Color.G">
            <summary>
            Gets the green value.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Color.B">
            <summary>
            Gets the blue value.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Color.#ctor(System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Color"/> structure.
            </summary>
            <param name="r">The red value.</param>
            <param name="g">The green value.</param>
            <param name="b">The blue value.</param>
        </member>
        <member name="M:MarcusW.VncClient.Color.ToPlainPixel">
            <summary>
            Returns the pixel data for this color using the <see cref="F:MarcusW.VncClient.PixelFormat.Plain"/> encoding.
            </summary>
            <returns>The pixel data.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Color.op_Equality(MarcusW.VncClient.Color,MarcusW.VncClient.Color)">
            <summary>
            Checks for equality between two <see cref="T:MarcusW.VncClient.Color"/>s.
            </summary>
            <param name="left">The first color.</param>
            <param name="right">The second color.</param>
            <returns>True if the colors are equal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Color.op_Inequality(MarcusW.VncClient.Color,MarcusW.VncClient.Color)">
            <summary>
            Checks for inequality between two <see cref="T:MarcusW.VncClient.Color"/>s.
            </summary>
            <param name="left">The first color.</param>
            <param name="right">The second color.</param>
            <returns>True if the colors are unequal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Color.Equals(MarcusW.VncClient.Color)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Color.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Color.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Color.ToString">
            <summary>
            Returns the string representation of the color.
            </summary>
            <returns>The string representation of the color.</returns>
        </member>
        <member name="T:MarcusW.VncClient.ConnectionState">
            <summary>
            The different states of an active RFB connection.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectionState.Uninitialized">
            <summary>
            Connection has not started yet.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectionState.Connected">
            <summary>
            Connection is established.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectionState.Interrupted">
            <summary>
            Connection was interrupted. Waiting for reconnect attempt after a short pause.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectionState.Reconnecting">
            <summary>
            Reconnect attempt is running.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectionState.ReconnectFailed">
            <summary>
            Reconnect attempt failed. Waiting for next reconnect attempt after a short pause.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectionState.Closed">
            <summary>
            Connection was closed or gave up reconnecting.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.ConnectParameters">
            <summary>
            Specifies the parameters for establishing a VNC connection.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.ConnectParameters.InfiniteReconnects">
            <summary>
            The value to specify unlimited reconnect attempts.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.TransportParameters">
            <summary>
            Specifies the transport type and parameters to connect to.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.ConnectTimeout">
            <summary>
            Gets or sets the connect timeout.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.ReconnectDelay">
            <summary>
            Gets or sets the delay between a connection being interrupted and a reconnect starting.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.MaxReconnectAttempts">
            <summary>
            Gets or sets the maximum number of reconnect attempts.
            </summary>
            <remarks>
            Set to <c>-1</c> for not limit.
            </remarks>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.AuthenticationHandler">
            <summary>
            Gets or sets the <see cref="T:MarcusW.VncClient.Security.IAuthenticationHandler"/> implementation that provides information for authenticating against the server.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.AllowSharedConnection">
            <summary>
            Gets or sets whether the server should leave other clients connected when this connection is established.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.InitialRenderTarget">
            <summary>
            Gets or sets the target where received frames should be rendered to, in case you want to set the target from the start on.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.RenderFlags">
            <summary>
            Gets or sets the flags that control, how the rendering to the target framebuffer should happen.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.InitialOutputHandler">
            <summary>
            Gets or sets the handler for output events from the server, in case you want to set the handler from the start on.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.JpegQualityLevel">
            <summary>
            Gets or sets the JPEG quality level in percent (0 to 100).
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.ConnectParameters.JpegSubsamplingLevel">
            <summary>
            Gets or sets the JPEG subsampling level.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.ConnectParameters.Validate">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.ConnectParameters.GetDescendants">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.JpegSubsamplingLevel">
            <summary>
            The different JPEG subsampling levels.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.JpegSubsamplingLevel.None">
            <summary>
            Chrominance components are sent for every pixel in the source image.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.JpegSubsamplingLevel.ChrominanceSubsampling4X">
            <summary>
            Chrominance components are sent for every fourth pixel in the source image.
            This would typically be implemented using 4:2:0 subsampling (2X subsampling in both X and Y directions), but it could also be implemented using 4:1:1
            subsampling (4X subsampling in the X direction.)
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.JpegSubsamplingLevel.ChrominanceSubsampling2X">
            <summary>
            2X chrominance subsampling. Chrominance components are sent for every other pixel in the source image.
            This would typically be implemented using 4:2:2 subsampling (2X subsampling in the X direction.)
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.JpegSubsamplingLevel.Grayscale">
            <summary>
            All chrominance components in the source image are discarded.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.JpegSubsamplingLevel.ChrominanceSubsampling8X">
            <summary>
            Chrominance components are sent for every 8th pixel in the source image.
            This would typically be implemented using 4:1:0 subsampling (4X subsampling in the X direction and 2X subsampling in the Y direction.)
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.JpegSubsamplingLevel.ChrominanceSubsampling16X">
            <summary>
            Chrominance components are sent for every 16th pixel in the source image.
            This would typically be implemented using 4X subsampling in both X and Y directions.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.MouseButtons">
            <summary>
            The different buttons of a mouse to describe pointer events.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Output.IOutputHandler">
            <summary>
            Provides methods for handling output events from the server.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Output.IOutputHandler.RingBell">
            <summary>
            Handles when the server rings the bell.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Output.IOutputHandler.HandleServerClipboardUpdate(System.String)">
            <summary>
            Handles when the clipboard content of the server changed.
            </summary>
            <param name="text">The text in the clipboard buffer.</param>
        </member>
        <member name="T:MarcusW.VncClient.PixelFormat">
            <summary>
            Represents a pixel format that's used for RFB encodings.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.PixelFormat.Unknown">
            <summary>
            An invalid pixel format representing unknown values.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.PixelFormat.Plain">
            <summary>
            A very basic RGBA pixel format.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.Name">
            <summary>
            Gets the name of this pixel format.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.BitsPerPixel">
            <summary>
            Gets the number of bits used for each pixel on the wire.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.Depth">
            <summary>
            Gets the number of useful bits in the pixel value. Must be greater than or equal to <see cref="P:MarcusW.VncClient.PixelFormat.BitsPerPixel"/>.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.BigEndian">
            <summary>
            Gets if multi-byte pixels are interpreted as big endian.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.TrueColor">
            <summary>
            Gets whether the pixel value is composed from the color values (True), or if the color values serve as indices into a color map (False).
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.HasAlpha">
            <summary>
            Gets whether this pixel format contains an alpha channel.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.RedMax">
            <summary>
            Gets the maximum value for the color red.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.GreenMax">
            <summary>
            Gets the maximum value for the color green.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.BlueMax">
            <summary>
            Gets the maximum value for the color blue.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.AlphaMax">
            <summary>
            Gets the maximum value for the alpha value.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.RedShift">
            <summary>
            Gets the number of right-shifts needed to get the red value in a pixel.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.GreenShift">
            <summary>
            Gets the number of right-shifts needed to get the green value in a pixel.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.BlueShift">
            <summary>
            Gets the number of right-shifts needed to get the blue value in a pixel.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.AlphaShift">
            <summary>
            Gets the number of right-shifts needed to get the alpha value in a pixel.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.BytesPerPixel">
            <summary>
            Gets the number of bytes used for each pixel on the wire.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.PixelFormat.LittleEndian">
            <summary>
            Gets if multi-byte pixels are interpreted as little endian.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.#ctor(System.String,System.Byte,System.Byte,System.Boolean,System.Boolean,System.Boolean,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.PixelFormat"/> structure.
            </summary>
            <param name="name">The name of the pixel format.</param>
            <param name="bitsPerPixel">The number of bits used for each pixel on the wire.</param>
            <param name="depth">The number of useful bits in the pixel value. Must be greater than or equal to <paramref name="bitsPerPixel"/>.</param>
            <param name="bigEndian">True if multi-byte pixels are interpreted as big endian, otherwise false.</param>
            <param name="trueColor">True if the pixel value is composed from the color values, or false if the color values serve as indices into a color map.</param>
            <param name="hasAlpha">True if this pixel format contains an alpha channel, otherwise false.</param>
            <param name="redMax">The maximum value for the color red.</param>
            <param name="greenMax">The maximum value for the color green.</param>
            <param name="blueMax">The maximum value for the color blue.</param>
            <param name="alphaMax">The maximum value for the alpha value.</param>
            <param name="redShift">The number of right-shifts needed to get the red value in a pixel.</param>
            <param name="greenShift">The number of right-shifts needed to get the green value in a pixel.</param>
            <param name="blueShift">The number of right-shifts needed to get the blue value in a pixel.</param>
            <param name="alphaShift">The number of right-shifts needed to get the alpha value in a pixel.</param>
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.IsBinaryCompatibleTo(MarcusW.VncClient.PixelFormat,System.Boolean)">
            <summary>
            Checks if a pixel encoded using this pixel format would be binary compatible with one encoded using another one.
            </summary>
            <remarks>
            This method does not yet support comparisons because little-endian and big-endian pixel formats.
            </remarks>
            <param name="other">The other pixel format.</param>
            <param name="ignoreAlpha">If true, the presence and encoding of the alpha channel will be ignored during this check.</param>
            <returns>True if they are binary compatible, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.op_Equality(MarcusW.VncClient.PixelFormat,MarcusW.VncClient.PixelFormat)">
            <summary>
            Checks for equality between two <see cref="T:MarcusW.VncClient.PixelFormat"/>s.
            </summary>
            <param name="left">The first pixel format.</param>
            <param name="right">The second pixel format.</param>
            <returns>True if the sizes are equal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.op_Inequality(MarcusW.VncClient.PixelFormat,MarcusW.VncClient.PixelFormat)">
            <summary>
            Checks for inequality between two <see cref="T:MarcusW.VncClient.PixelFormat"/>s.
            </summary>
            <param name="left">The first pixel format.</param>
            <param name="right">The second pixel format.</param>
            <returns>True if the sizes are unequal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.Equals(MarcusW.VncClient.PixelFormat)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.PixelFormat.ToString">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Position">
            <summary>
            Represents a position in device pixels.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Position.Origin">
            <summary>
            A position representing the origin of a coordinate system.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Position.X">
            <summary>
            Gets the X coordinate.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Position.Y">
            <summary>
            Gets the Y coordinate.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Position.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Position"/> structure.
            </summary>
            <param name="x">The X coordinate.</param>
            <param name="y">The Y coordinate.</param>
        </member>
        <member name="M:MarcusW.VncClient.Position.op_Equality(MarcusW.VncClient.Position,MarcusW.VncClient.Position)">
            <summary>
            Checks for equality between two <see cref="T:MarcusW.VncClient.Position"/>s.
            </summary>
            <param name="left">The first position.</param>
            <param name="right">The second position.</param>
            <returns>True if the positions are equal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Position.op_Inequality(MarcusW.VncClient.Position,MarcusW.VncClient.Position)">
            <summary>
            Checks for inequality between two <see cref="T:MarcusW.VncClient.Position"/>s.
            </summary>
            <param name="left">The first position.</param>
            <param name="right">The second position.</param>
            <returns>True if the positions are unequal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Position.Equals(MarcusW.VncClient.Position)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Position.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Position.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Position.ToString">
            <summary>
            Returns the string representation of the position.
            </summary>
            <returns>The string representation of the position.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType">
            <summary>
            Represents a RFB protocol encoding type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType.Id">
            <summary>
            Gets the ID for this encoding type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType.Name">
            <summary>
            Gets a human readable name for this encoding type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType.Priority">
            <summary>
            Gets the priority value that represents the quality of this encoding type.
            The server might prefer encoding types with a higher priority.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType.GetsConfirmed">
            <summary>
            Gets whether the server will confirm somehow that it supports this encoding type,
            or if we just expect it to be supported by the server without knowing, if the server actually understood
            the encoding type we requested during SetEncodings.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.EncodingTypes.IFrameEncodingType">
            <summary>
            Represents a RFB protocol encoding type for (part of) a frame.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.EncodingTypes.IFrameEncodingType.VisualizationColor">
            <summary>
            Gets a distinctive color for visualizing rectangles that were encoded with this type (when enabled).
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.EncodingTypes.IFrameEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <summary>
            Reads a (partial) frame from the transport stream, decodes it and renders it to the target framebuffer, if available.
            </summary>
            <param name="transportStream">The stream to read from.</param>
            <param name="targetFramebuffer">The target framebuffer reference, or null if unavailable.</param>
            <param name="rectangle">The part of the frame to update.</param>
            <param name="remoteFramebufferSize">The current size of the remote framebuffer.</param>
            <param name="remoteFramebufferFormat">The current pixel format.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.EncodingTypes.IPseudoEncodingType">
            <summary>
            Represents a RFB protocol encoding type for extended functionality.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.EncodingTypes.IPseudoEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <summary>
            Reads a pseudo encoding from the transport stream, decodes it and acts accordingly.
            </summary>
            <param name="transportStream">The stream to read from.</param>
            <param name="rectangle">The rectangle that was received with the pseudo encoding. Might be relevant sometimes.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.EncodingTypes.WellKnownEncodingType">
            <summary>
            The well known encoding types and their IDs.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.SecurityTypesCollectionBuilderDelegate">
            <summary>
            Represents the method that builds a new <see cref="T:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType"/> collection.
            </summary>
            <param name="context">Details about the associated connection.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypesCollectionBuilderDelegate">
            <summary>
            Represents the method that builds a new <see cref="T:MarcusW.VncClient.Protocol.MessageTypes.IMessageType"/> collection.
            </summary>
            <param name="context">Details about the associated connection.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypesCollectionBuilderDelegate">
            <summary>
            Represents the method that builds a new <see cref="T:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType"/> collection.
            </summary>
            <param name="context">Details about the associated connection.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation">
            <summary>
            Default implementation of the RFB protocol.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.IsTightAvailable">
            <summary>
            Gets whether the Tight encoding type is available. If it's not, consider installing the TurboJPEG library on your system.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation"/>.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.#ctor(MarcusW.VncClient.Protocol.Implementation.SecurityTypesCollectionBuilderDelegate,MarcusW.VncClient.Protocol.Implementation.MessageTypesCollectionBuilderDelegate,MarcusW.VncClient.Protocol.Implementation.EncodingTypesCollectionBuilderDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation"/>.
            </summary>
            <param name="securityTypesCollectionBuilder">A method that newly creates all the security types that are supported by this protocol instance. See <see cref="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.GetDefaultSecurityTypes(MarcusW.VncClient.Protocol.RfbConnectionContext)"/>.</param>
            <param name="messageTypesCollectionBuilder">A method that newly creates all the message types that are supported by this protocol instance. See <see cref="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.GetDefaultMessageTypes(MarcusW.VncClient.Protocol.RfbConnectionContext)"/>.</param>
            <param name="encodingTypesCollectionBuilder">A method that newly creates all the encoding types that are supported by this protocol instance. See <see cref="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.GetDefaultEncodingTypes(MarcusW.VncClient.Protocol.RfbConnectionContext)"/>.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateStateObject(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateSecurityTypesCollection(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateMessageTypesCollection(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateEncodingTypesCollection(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateTransportConnector(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateRfbHandshaker(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateRfbInitializer(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateMessageReceiver(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateMessageSender(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateZLibInflater(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.CreateJpegDecoder(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.GetDefaultSecurityTypes(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Builds a collection with all RFB security types that are officially supported by this protocol implementation.
            Feel free to extend the returned enumerable with custom types.
            </summary>
            <param name="context">The connection context.</param>
            <returns>The security type collection.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.GetDefaultMessageTypes(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Builds a collection with all RFB message types that are officially supported by this protocol implementation.
            Feel free to extend the returned enumerable with custom message types.
            </summary>
            <param name="context">The connection context.</param>
            <returns>The message types collection.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.DefaultImplementation.GetDefaultEncodingTypes(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Builds a collection with all RFB encoding types that are officially supported by this protocol implementation.
            Feel free to extend the returned enumerable with custom types.
            </summary>
            <param name="context">The connection context.</param>
            <returns>The encoding types collection.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType">
            <summary>
            A frame encoding for copying a rectangle to another place.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType.VisualizationColor">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.CopyRectEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType">
            <summary>
            Base class for <see cref="T:MarcusW.VncClient.Protocol.EncodingTypes.IFrameEncodingType"/> implementations.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType.VisualizationColor">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.FrameEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType">
            <summary>
            A frame encoding type for raw pixel data.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType.VisualizationColor">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.RawEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType">
            <summary>
            A frame encoding type for Tight compressed pixel data.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.VisualizationColor">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.TightEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType">
            <summary>
            A frame encoding type for zlib compressed raw pixel data.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.VisualizationColor">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZLibEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType">
            <summary>
            A frame encoding type for ZRLE compressed pixel data.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.VisualizationColor">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Frame.ZrleEncodingType.ReadFrameEncoding(System.IO.Stream,MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@,MarcusW.VncClient.Size@,MarcusW.VncClient.PixelFormat@)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ContinuousUpdatesEncodingType">
            <summary>
            A pseudo encoding type to detect server-side support for continuous updates.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ContinuousUpdatesEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ContinuousUpdatesEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ContinuousUpdatesEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ContinuousUpdatesEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType">
            <summary>
            A pseudo encoding type to receive changes of the remote framebuffer size.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.DesktopSizeEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType">
            <summary>
            A pseudo encoding type to receive changes of the remote framebuffer size and screen layout.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ExtendedDesktopSizeEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.FenceEncodingType">
            <summary>
            A pseudo encoding type to detect server-side support for fences.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.FenceEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.FenceEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.FenceEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.FenceEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.ILastRectEncodingType">
            <summary>
            An interface to mark an encoding type implementation as being the LastRect pseudo encoding.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType">
            <summary>
            A pseudo encoding which informs the server about the wished fine-grained JPEG quality level.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegFineGrainedQualityLevelEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType">
            <summary>
            A pseudo encoding which informs the server about the wished JPEG quality level.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegQualityLevelEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType">
            <summary>
            A pseudo encoding which informs the server about the wished JPEG subsampling level.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.JpegSubsamplingLevelEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.LastRectEncodingType">
            <summary>
            A pseudo encoding type to detect the last rectangle in a framebuffer update message.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.LastRectEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.LastRectEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.LastRectEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.LastRectEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.PseudoEncodingType">
            <summary>
            Base class for <see cref="T:MarcusW.VncClient.Protocol.EncodingTypes.IPseudoEncodingType"/> implementations.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.PseudoEncodingType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.PseudoEncodingType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.PseudoEncodingType.Priority">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.PseudoEncodingType.GetsConfirmed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.EncodingTypes.Pseudo.PseudoEncodingType.ReadPseudoEncoding(System.IO.Stream,MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.FenceFlags">
            <summary>
            The flags sent with a ServerFence or ClientFence message.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.FenceFlags.BlockBefore">
            <summary>
            All messages preceding this one must have finished processing and taken effect before the response is sent.
            Messages following this one are unaffected and may be processed in any order the protocol permits, even before the response is sent.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.FenceFlags.BlockAfter">
            <summary>
            All messages following this one must not start processing until the response is sent.
            Messages preceding this one are unaffected and may be processed in any order the protocol permits, even being delayed until after the response is sent.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.FenceFlags.SyncNext">
            <summary>
            The message following this one must be executed in an atomic manner so that anything preceding the fence response must not be affected by the message,
            and anything following the fence response must be affected by the message.
            Anything unaffected by the following message can be sent at any time the protocol permits.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.FenceFlags.Request">
            <summary>
            Indicates that this is a new request and that a response is expected. If this bit is cleared then this message is a response to an earlier request.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor">
            <summary>
            Represents a cursor for iterating over pixels of a rectangle inside of a framebuffer.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.#ctor(MarcusW.VncClient.Rendering.IFramebufferReference,MarcusW.VncClient.Rectangle@)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor"/> structure.
            </summary>
            <param name="framebufferReference">The target framebuffer reference.</param>
            <param name="rectangle">The target rectangle.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.#ctor(System.Byte*,MarcusW.VncClient.PixelFormat@,MarcusW.VncClient.Size@,MarcusW.VncClient.Rectangle@)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor"/> structure.
            </summary>
            <param name="framebufferPtr">The pointer to the framebuffer location.</param>
            <param name="framebufferFormat">The framebuffer format.</param>
            <param name="framebufferSize">The framebuffer size.</param>
            <param name="rectangle">The target rectangle.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.GetEndReached">
            <summary>
            Gets whether the cursor reached the last pixel of the rectangle.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.MoveNext">
            <summary>
            Moves the cursor to the next pixel of the rectangle.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.MoveForwardInLine(System.Int32)">
            <summary>
            Moves the cursor a few pixels forward in the current line.
            </summary>
            <param name="count">The amount of pixels to move the cursor forward.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.SetPixel(MarcusW.VncClient.Color)">
            <summary>
            Sets the pixel color on the current position in the rectangle.
            </summary>
            <param name="color">The desired color.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.SetPixel(System.Byte*,MarcusW.VncClient.PixelFormat@)">
            <summary>
            Sets the pixel color on the current position in the rectangle.
            </summary>
            <param name="pixelData">A pointer to a memory location where the color data is stored.</param>
            <param name="pixelFormat">The format of the pixel data.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.SetPixelsSolid(MarcusW.VncClient.Color,System.Int32)">
            <summary>
            Sets <see cref="!:numPixels"/> pixels all to the same color value and advances the cursor accordingly.
            </summary>
            <param name="color">The desired color.</param>
            <param name="numPixels">The number of pixels to set.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.SetPixelsSolid(System.Byte*,MarcusW.VncClient.PixelFormat@,System.Int32)">
            <summary>
            Sets <see cref="!:numPixels"/> pixels all to the same color value and advances the cursor accordingly.
            </summary>
            <param name="pixelData">A pointer to a memory location where the color data is stored.</param>
            <param name="pixelFormat">The format of the pixel data.</param>
            <param name="numPixels">The number of pixels to set.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.SetPixels(System.Byte*,MarcusW.VncClient.PixelFormat@,System.Int32)">
            <summary>
            Sets <see cref="!:numPixels"/> pixels and advances the cursor accordingly.
            </summary>
            <param name="pixelData">A pointer to a memory location where the data for <see cref="!:numPixels"/> is stored.</param>
            <param name="pixelFormat">The format of the pixel data.</param>
            <param name="numPixels">The number of pixels to set.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.CopyAllFrom(MarcusW.VncClient.Protocol.Implementation.FramebufferCursor@)">
            <summary>
            Copies all pixels accessible by an other cursor to the current rectangle when both rectangles have the same size.
            </summary>
            <param name="otherCursor">The other cursor.</param>
            <remarks>
            Both cursors must point to the start of their rectangle.
            The current cursor position is advanced by the written pixels, the other cursor won't be touched.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.Equals(MarcusW.VncClient.Protocol.Implementation.FramebufferCursor)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.FramebufferCursor.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType">
            <summary>
            A message type for receiving a server bell message.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.BellMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType">
            <summary>
            A message type for processing the end of a continuous updates phase.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.EndOfContinuousUpdatesMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType">
            <summary>
            A message type for receiving FramebufferUpdate messages and rendering the contained rectangles to the framebuffer.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.FramebufferUpdateMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType">
            <summary>
            A message type for receiving updates about the cut buffer (clipboard) of the server.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerCutTextMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType">
            <summary>
            A message type for receiving and responding to a server-side fence message.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.ServerFenceMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType">
            <summary>
            A message type for receiving a color map.
            </summary>
            <remarks>
            Color maps are currently not supported by this protocol implementation. Therefore the received color map is discarded.
            </remarks>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Incoming.SetColourMapEntriesMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage">
            <summary>
            A message for requesting a ServerFence or replying to one.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage.Flags">
            <summary>
            Gets the fence flags.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage.Payload">
            <summary>
            Gets the fence payload.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage.#ctor(MarcusW.VncClient.Protocol.Implementation.FenceFlags,System.Byte[])">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage"/>.
            </summary>
            <param name="flags">The fence flags.</param>
            <param name="payload">The fence payload (limited to 64 bytes).</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.ClientFenceMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage">
            <summary>
            A message for enabling continuous updates.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage.Enable">
            <summary>
            Gets whether continuous updates should be enabled or disabled.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage.Rectangle">
            <summary>
            Gets the rectangle that should be continuously updated.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage.#ctor(System.Boolean,MarcusW.VncClient.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage"/>.
            </summary>
            <param name="enable">True if continuous updates should be enabled, false to disable them.</param>
            <param name="rectangle">The rectangle that should be continuously updated.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.EnableContinuousUpdatesMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage">
            <summary>
            A message that requests a framebuffer update from the server.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage.Incremental">
            <summary>
            Gets whether the framebuffer update should be incremental.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage.Rectangle">
            <summary>
            Gets the rectangle that should be updated.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage.#ctor(System.Boolean,MarcusW.VncClient.Rectangle)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage"/>.
            </summary>
            <param name="incremental">True if the framebuffer update should be incremental, otherwise false.</param>
            <param name="rectangle">The rectangle that should be updated.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.FramebufferUpdateRequestMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage">
            <summary>
            A message for telling the server about key events.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage.DownFlag">
            <summary>
            Gets whether this is a key down or key up event.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage.KeySymbol">
            <summary>
            Gets the key symbol as defined by the X Window System.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage.#ctor(System.Boolean,MarcusW.VncClient.KeySymbol)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage"/>.
            </summary>
            <param name="downFlag">True, if this is a key down event, false for key up.</param>
            <param name="keySymbol">The key symbol as defined by the X Window System.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.KeyEventMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage">
            <summary>
            A message for telling the server about mouse pointer events.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage.PointerPosition">
            <summary>
            Gets the pointer position.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage.PressedButtons">
            <summary>
            Gets the pressed buttons.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage.#ctor(MarcusW.VncClient.Position,MarcusW.VncClient.MouseButtons)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage"/>.
            </summary>
            <param name="pointerPosition">The pointer position.</param>
            <param name="pressedButtons">The pressed buttons.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.PointerEventMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage">
            <summary>
            A message for updating the remote framebuffer size and layout.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage.MutationFuncDelegate">
            <summary>
            Represents the method that mutates a remote framebuffer size and layout.
            </summary>
            <param name="size">The current size.</param>
            <param name="layout">The current layout.</param>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage.MutationFunc">
            <summary>
            Gets the function that mutates the current remote framebuffer size and layout.
            It will be called by the sender thread right before the message gets sent.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage.#ctor(MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage.MutationFuncDelegate)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage"/>.
            </summary>
            <param name="mutationFunc">
            The function that mutates the current remote framebuffer size and layout.
            It will be called by the sender thread right before the message gets sent.
            </param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetDesktopSizeMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessageType">
            <summary>
            A message type for sending <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessage"/>s.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessageType.Id">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessageType.Name">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessageType.IsStandardMessageType">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessage">
            <summary>
            A message declaring which encoding types the client supports.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessage.SupportedEncodingTypes">
            <summary>
            Gets the encoding types collection that will be reported to the server.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessage.#ctor(System.Collections.Immutable.IImmutableSet{MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType})">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessage"/>.
            </summary>
            <param name="supportedEncodingTypes">The encoding types collection that will be reported to the server.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.MessageTypes.Outgoing.SetEncodingsMessage.GetParametersOverview">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg">
            <summary>
            Native bindings for the TurboJPEG library.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.IsAvailable">
            <summary>
            Gets whether the library is available on the current system.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.InitDecompressorInstance">
            <summary>
            Create a TurboJPEG decompressor instance.
            </summary>
            <returns>A handle to the newly created instance, or <see langword="null"/> if an error occurred (see <see cref="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.GetLastError"/>).</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.DestroyInstance(System.IntPtr)">
            <summary>
            Destroy a TurboJPEG compressor, decompressor, or transformer instance.
            </summary>
            <param name="handle">The handle.</param>
            <returns>0 if successful, or -1 if an error occurred (see <see cref="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.GetLastError"/>).</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.DecompressHeader(System.IntPtr,System.IntPtr,System.UInt64,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Retrieve information about a JPEG image without decompressing it.
            </summary>
            <param name="handle">A handle to a TurboJPEG decompressor or transformer instance.</param>
            <param name="jpegBuf">Pointer to a buffer containing a JPEG image. This buffer is not modified.</param>
            <param name="jpegSize">Size of the JPEG image (in bytes).</param>
            <param name="width">An integer variable that will receive the width (in pixels) of the JPEG image.</param>
            <param name="height">An integer variable that will receive the height (in pixels) of the JPEG image.</param>
            <param name="subsampling">An integer variable that will receive the level of chrominance subsampling used when the JPEG image was compressed.</param>
            <param name="colorspace">An integer variable that will receive one of the JPEG colorspace constants, indicating the colorspace of the JPEG image.</param>
            <returns>0 if successful, or -1 if an error occurred (see <see cref="!:TjGetErrorStr"/>).</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.Decompress(System.IntPtr,System.IntPtr,System.UInt64,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Decompress a JPEG image to an RGB, grayscale, or CMYK image.
            </summary>
            <param name="handle">A handle to a TurboJPEG decompressor or transformer instance.</param>
            <param name="jpegBuf">Pointer to a buffer containing the JPEG image to decompress. This buffer is not modified.</param>
            <param name="jpegSize">Size of the JPEG image (in bytes).</param>
            <param name="dstBuf">Pointer to an image buffer that will receive the decompressed image.</param>
            <param name="width">
            Desired width (in pixels) of the destination image.
            If this is different than the width of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible
            image that will fit within the desired width. If <paramref name="width"/> is set to 0, then only the height will be considered when determining the scaled image size.
            </param>
            <param name="pitch">
            Bytes per line in the destination image.
            Normally, this is <c>scaledWidth * tjPixelSize[pixelFormat]</c> if the decompressed image is unpadded, else <c>TJPAD(scaledWidth * tjPixelSize[pixelFormat])</c> if each
            line of the decompressed image is padded to the nearest 32-bit boundary, as is the case for Windows bitmaps.
            You can also be clever and use the pitch parameter to skip lines, etc.
            Setting this parameter to 0 is the equivalent of setting it to <c>scaledWidth* tjPixelSize[pixelFormat]</c>.
            </param>
            <param name="height">
            Desired height (in pixels) of the destination image.
            If this is different than the height of the JPEG image being decompressed, then TurboJPEG will use scaling in the JPEG decompressor to generate the largest possible
            image that will fit within the desired height. If <paramref name="height"/> is set to 0, then only the width will be considered when determining the scaled image size.
            </param>
            <param name="pixelFormat">Pixel format of the destination image (see <see cref="T:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat"/>).</param>
            <param name="flags">The bitwise OR of one or more of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags"/>.</param>
            <returns>0 if successful, or -1 if an error occurred (see <see cref="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.GetLastError"/>).</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpeg.GetLastError">
            <summary>
            Returns a descriptive error message explaining why the last command failed.
            </summary>
            <returns>An error message.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags">
            <summary>
            The different TurboJPEG flags.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags.None">
            <summary>
            Flags not set
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags.BottomUp">
            <summary>
            The uncompressed source/destination image is stored in bottom-up (Windows, OpenGL) order,
            not top-down (X11) order.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags.FastUpsample">
            <summary>
            When decompressing an image that was compressed using chrominance subsampling,
            use the fastest chrominance upsampling algorithm available in the underlying codec.
            The default is to use smooth upsampling, which creates a smooth transition between
            neighboring chrominance components in order to reduce upsampling artifacts in the decompressed image.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags.NoRealloc">
            <summary>
            Disable buffer (re)allocation. If passed to <see cref="!:TurboJpegImport.TjCompress2"/> or #tjTransform(),
            this flag will cause those functions to generate an error
            if the JPEG image buffer is invalid or too small rather than attempting to allocate or reallocate that buffer.
            This reproduces the behavior of earlier versions of TurboJPEG.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags.FastDct">
            <summary>
            Use the fastest DCT/IDCT algorithm available in the underlying codec. The
            default if this flag is not specified is implementation-specific. For
            example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
            algorithm by default when compressing, because this has been shown to have
            only a very slight effect on accuracy, but it uses the accurate algorithm
            when decompressing, because this has been shown to have a larger effect.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegFlags.AccurateDct">
            <summary>
            Use the most accurate DCT/IDCT algorithm available in the underlying codec.
            The default if this flag is not specified is implementation-specific. For
            example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
            algorithm by default when compressing, because this has been shown to have
            only a very slight effect on accuracy, but it uses the accurate algorithm
            when decompressing, because this has been shown to have a larger effect.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat">
            <summary>
            The different TurboJPEG pixel formats.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.RGB">
            <summary>
            RGB pixel format. The red, green, and blue components in the image are
            stored in 3-byte pixels in the order R, G, B from lowest to highest byte
            address within each pixel.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.BGR">
            <summary>
            BGR pixel format. The red, green, and blue components in the image are
            stored in 3-byte pixels in the order B, G, R from lowest to highest byte
            address within each pixel.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.RGBX">
            <summary>
            RGBX pixel format. The red, green, and blue components in the image are
            stored in 4-byte pixels in the order R, G, B from lowest to highest byte
            address within each pixel. The X component is ignored when compressing
            and undefined when decompressing.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.BGRX">
            <summary>
            BGRX pixel format. The red, green, and blue components in the image are
            stored in 4-byte pixels in the order B, G, R from lowest to highest byte
            address within each pixel. The X component is ignored when compressing
            and undefined when decompressing.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.XBGR">
            <summary>
            XBGR pixel format. The red, green, and blue components in the image are
            stored in 4-byte pixels in the order R, G, B from highest to lowest byte
            address within each pixel. The X component is ignored when compressing
            and undefined when decompressing.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.XRGB">
            <summary>
            XRGB pixel format. The red, green, and blue components in the image are
            stored in 4-byte pixels in the order B, G, R from highest to lowest byte
            address within each pixel. The X component is ignored when compressing
            and undefined when decompressing.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.Gray">
            <summary>
            Grayscale pixel format. Each 1-byte pixel represents a luminance
            (brightness) level from 0 to 255.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.RGBA">
            <summary>
            RGBA pixel format. This is the same as <see cref="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.RGBX"/>, except that when
            decompressing, the X component is guaranteed to be 0xFF, which can be
            interpreted as an opaque alpha channel.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.BGRA">
            <summary>
            BGRA pixel format. This is the same as <see cref="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.BGRX"/>, except that when
            decompressing, the X component is guaranteed to be 0xFF, which can be
            interpreted as an opaque alpha channel.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.ABGR">
            <summary>
            ABGR pixel format. This is the same as <see cref="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.XBGR"/>, except that when
            decompressing, the X component is guaranteed to be 0xFF, which can be
            interpreted as an opaque alpha channel.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.ARGB">
            <summary>
            ARGB pixel format. This is the same as <see cref="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.XRGB"/>, except that when
            decompressing, the X component is guaranteed to be 0xFF, which can be
            interpreted as an opaque alpha channel.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.Implementation.Native.TurboJpegPixelFormat.CMYK">
            <summary>
            CMYK pixel format. Unlike RGB, which is an additive color model used
            primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive
            color model used primarily for printing. In the CMYK color model, the
            value of each color component typically corresponds to an amount of cyan,
            magenta, yellow, or black ink that is applied to a white background. In
            order to convert between CMYK and RGB, it is necessary to use a color
            management system (CMS.) A CMS will attempt to map colors within the
            printer's gamut to perceptually similar colors in the display's gamut and
            vice versa, but the mapping is typically not 1:1 or reversible, nor can it
            be defined with a simple formula. Thus, such a conversion is out of scope
            for a codec library. However, the TurboJPEG API allows for compressing
            CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK
            JPEG images into CMYK pixels.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.PixelConversions">
            <summary>
            Provides methods for converting a pixel value from one format to another.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.PixelConversions.WritePixel(System.Byte*,MarcusW.VncClient.PixelFormat@,System.Byte*,MarcusW.VncClient.PixelFormat@)">
            <summary>
            Reads pixel data from <paramref name="pixelPtr"/>, converts it to <paramref name="targetFormat"/> and writes it to the target buffer.
            </summary>
            <param name="pixelPtr">The position of the source pixel data.</param>
            <param name="pixelFormat">The format of the source pixel data.</param>
            <param name="targetPtr">The position for the target pixel data.</param>
            <param name="targetFormat">The format for the target pixel data.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.PixelUtils">
            <summary>
            Provides some useful methods for working with pixel values and formats.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.PixelUtils.GetChannelDepth(System.UInt16)">
            <summary>
            Counts the number of high bits in the maximum value for a color channel to retrieve how many bits a channel occupies.
            </summary>
            <param name="maxValue">The maximum value for the color channel.</param>
            <returns>The channel depth.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.ProtocolState">
            <inhertitdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.ProtocolVersion">
            <summary>
            Gets or sets the used protocol version.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.UsedSecurityType">
            <summary>
            Gets or sets the security type that was negotiated during handshake.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.UsedMessageTypes">
            <summary>
            Gets or sets the message types that are known to be supported by both sides.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.UsedEncodingTypes">
            <summary>
            Gets or sets the encoding types that are known to be supported by both sides.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.RemoteFramebufferSize">
            <summary>
            Gets or sets the current remote framebuffer size.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.RemoteFramebufferFormat">
            <summary>
            Gets or sets the current remote framebuffer format.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.RemoteFramebufferLayout">
            <summary>
            Gets or sets the current remote framebuffer layout.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.DesktopName">
            <summary>
            Gets or sets the current desktop name.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.ServerSupportsFences">
            <summary>
            Gets or sets whether the server supports fences.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.ServerSupportsContinuousUpdates">
            <summary>
            Gets or sets whether the server supports continuous updates.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.ServerSupportsExtendedDesktopSize">
            <summary>
            Gets or sets whether the server supports the extended desktop size extension.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.ProtocolState.ContinuousUpdatesEnabled">
            <summary>
            Gets or sets whether continuous updates are currently enabled.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.ProtocolState.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.ProtocolState"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.ProtocolState.Prepare">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.ProtocolState.EnsureMessageTypeIsMarkedAsUsed``1(``0,System.Nullable{System.Byte})">
            <summary>
            Marks the given message type as being supported by both sides, if that not already happened.
            </summary>
            <param name="messageType">The message type instance, if already at hand.</param>
            <param name="idFilter">An optional filter in case <typeparamref name="TMessageType"/> is not specific enough.</param>
            <typeparam name="TMessageType">The type of the message type or a base type like <see cref="T:MarcusW.VncClient.Protocol.MessageTypes.IIncomingMessageType"/>.</typeparam>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.ProtocolState.EnsureEncodingTypeIsMarkedAsUsed``1(``0,System.Nullable{System.Int32})">
            <summary>
            Marks the given encoding type as being supported by both sides, if that not already happened.
            </summary>
            <param name="encodingType">The encoding type instance, if already at hand.</param>
            <param name="idFilter">An optional filter in case <typeparamref name="TEncodingType"/> is not specific enough.</param>
            <typeparam name="TEncodingType">The type of the encoding type or a base type like <see cref="T:MarcusW.VncClient.Protocol.EncodingTypes.IFrameEncodingType"/>.</typeparam>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType">
            <summary>
            A security type without any security.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType.Id">
            <inhertitdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType.Name">
            <inhertitdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType.Priority">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType.AuthenticateAsync(MarcusW.VncClient.Security.IAuthenticationHandler,System.Threading.CancellationToken)">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.NoneSecurityType.ReadServerInitExtensionAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType">
            <summary>
            A security type which uses DES for a simple password authentication but does not provide any further transport encryption.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType.Id">
            <inhertitdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType.Name">
            <inhertitdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType.Priority">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType.AuthenticateAsync(MarcusW.VncClient.Security.IAuthenticationHandler,System.Threading.CancellationToken)">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.SecurityTypes.VncAuthenticationSecurityType.ReadServerInitExtensionAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Communication.BuiltinZLibInflater">
            <summary>
            A <see cref="T:MarcusW.VncClient.Protocol.Services.IZLibInflater"/> implementation using the builtin System.IO.Compression implementation of zlib.
            Provides methods for inflating (decompressing) received data using per-connection zlib streams.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.BuiltinZLibInflater.ReadAndInflate(System.IO.Stream,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.BuiltinZLibInflater.ResetZlibStream(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.BuiltinZLibInflater.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageReceiver">
            <summary>
            A background thread that receives and processes RFB protocol messages.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageReceiver.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageReceiver"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageReceiver.StartReceiveLoop">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageReceiver.StopReceiveLoopAsync">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender">
            <summary>
            A background thread that sends queued messages and provides methods to add messages to the send queue.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.StartSendLoop">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.StopSendLoopAsync">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.EnqueueInitialMessages(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.EnqueueMessage``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.SendMessageAndWait``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.SendMessageAndWaitAsync``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.RfbMessageSender.Dispose(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Communication.TurboJpegDecoder">
            <summary>
            A <see cref="T:MarcusW.VncClient.Protocol.Services.IJpegDecoder"/> implementation using the TurboJPEG library.
            Provides methods for decoding JPEG images.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.Services.Communication.TurboJpegDecoder.IsAvailable">
            <summary>
            Gets whether this decoder is available on the current system.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.TurboJpegDecoder.DecodeJpegTo32Bit(System.Span{System.Byte},System.Span{System.Byte},System.Int32,System.Int32,MarcusW.VncClient.PixelFormat,MarcusW.VncClient.PixelFormat@,System.Threading.CancellationToken)">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.TurboJpegDecoder.Dispose">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Communication.TurboJpegDecoder.Finalize">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Handshaking.RfbHandshaker">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Handshaking.RfbHandshaker.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Services.Handshaking.RfbHandshaker"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Handshaking.RfbHandshaker.DoHandshakeAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Initialization.RfbInitializer">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Initialization.RfbInitializer.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Services.Initialization.RfbInitializer"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Initialization.RfbInitializer.InitializeAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransport">
            <summary>
            A transport which provides a stream for communication over a plain TCP connection.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransport.Stream">
            <inhertitdoc />
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransport.IsEncrypted">
            <inhertitdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransport.#ctor(System.Net.Sockets.TcpClient)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransport"/>.
            </summary>
            <param name="tcpClient">The tcp client.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransport.Dispose">
            <inhertitdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransportParameters">
            <summary>
            Specifies the parameters for establishing a TCP transport.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransportParameters.Host">
            <summary>
            Gets or sets the name or address of the target host.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransportParameters.Port">
            <summary>
            Gets or sets the target port.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransportParameters.Validate">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransportParameters.GetDescendants">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TcpTransportParameters.ToString">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TransportConnector">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TransportConnector.#ctor(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TransportConnector"/>.
            </summary>
            <param name="context">The connection context.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.Services.Transports.TransportConnector.ConnectAsync(System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Implementation.StreamExtensions">
            <summary>
            Extension methods for <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.StreamExtensions.ReadAll(System.IO.Stream,System.Span{System.Byte},System.Threading.CancellationToken)">
            <summary>
            Reads a chunk of bytes from the stream and waits until all bytes are received.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="buffer">The buffer to read to.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.StreamExtensions.ReadAllAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads a chunk of bytes from the stream and waits asynchronously until all bytes are received.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="numBytes">The number of bytes to read.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The read bytes.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.StreamExtensions.SkipAll(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads and discards the given amount of bytes from the stream and waits until all bytes are received.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="numBytes">The number of bytes to skip.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Implementation.StreamExtensions.CopyAllTo(System.IO.Stream,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads a specified amount of bytes from the current stream and writes them to another stream.
            </summary>
            <param name="stream">The stream to read from.</param>
            <param name="target">The target stream to write to.</param>
            <param name="numBytes">The number of bytes to copy.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.IRfbProtocolImplementation">
            <summary>
            Provides access to different elements of a RFB protocol implementation.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateStateObject(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.IRfbProtocolState"/> state object.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new state object.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateSecurityTypesCollection(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new collection of all supported <see cref="T:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType"/>s.
            </summary>
            <remarks>
            Make sure the security types are newly instantiated on each call, because it's
            not guaranteed that they can safely be used across multiple connections simultaneously.
            </remarks>
            <param name="context">Details about the associated connection.</param>
            <returns>An immutable set with all supported security types.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateMessageTypesCollection(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new collection of all supported <see cref="T:MarcusW.VncClient.Protocol.MessageTypes.IMessageType"/>s.
            </summary>
            <remarks>
            Make sure the message types are newly instantiated on each call, because it's
            not guaranteed that they can safely be used across multiple connections simultaneously.
            </remarks>
            <param name="context">Details about the associated connection.</param>
            <returns>An immutable set with all supported message types.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateEncodingTypesCollection(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new collection of all supported <see cref="T:MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType"/>s.
            </summary>
            <remarks>
            Make sure the encoding types are newly instantiated on each call, because it's
            not guaranteed that they can safely be used across multiple connections simultaneously.
            </remarks>
            <param name="context">Details about the associated connection.</param>
            <returns>An immutable set with all supported encoding types.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateTransportConnector(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.ITransportConnector"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the transport connector.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateRfbHandshaker(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.IRfbHandshaker"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the RFB handshaker.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateRfbInitializer(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.IRfbInitializer"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the RFB initializer.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateMessageReceiver(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.IRfbMessageReceiver"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the message receiver.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateMessageSender(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.IRfbMessageSender"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the message sender.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateZLibInflater(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.IZLibInflater"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the zlib inflater.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolImplementation.CreateJpegDecoder(MarcusW.VncClient.Protocol.RfbConnectionContext)">
            <summary>
            Creates a new <see cref="T:MarcusW.VncClient.Protocol.Services.IJpegDecoder"/>.
            </summary>
            <param name="context">Details about the associated connection.</param>
            <returns>A new instance of the jpeg decoder.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.IRfbProtocolState">
            <summary>
            Represents a class that holds all the variable state information for the RFB protocol implementation.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.IRfbProtocolState.Prepare">
            <summary>
            Prepares the state object for first use.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.ITransport">
            <summary>
            Represents an open transport through which bytes to/from the server can be sent and received.
            </summary>
            <remarks>
            You can build a <see cref="T:MarcusW.VncClient.Protocol.ITransport"/> which contains another transport to implement tunnel protocols.
            </remarks>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.ITransport.Stream">
            <summary>
            Gets the stream for sending and receiving bytes.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.ITransport.IsEncrypted">
            <summary>
            Gets whether the data on this transport gets encrypted.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.MessageTypes.IIncomingMessageType">
            <summary>
            Represents a server-to-client message type of the RFB protocol.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.MessageTypes.IIncomingMessageType.ReadMessage(MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <summary>
            Reads the message (everything after the message type byte) from the transport stream and processes it.
            </summary>
            <param name="transport">The transport to read from.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.MessageTypes.IMessageType">
            <summary>
            Represents a RFB protocol message type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.MessageTypes.IMessageType.Id">
            <summary>
            Gets the ID for this message type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.MessageTypes.IMessageType.Name">
            <summary>
            Gets a human readable name for this message type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.MessageTypes.IMessageType.IsStandardMessageType">
            <summary>
            Gets whether this is a standard message type that must be supported by all servers and clients.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage`1">
            <summary>
            Represents a client-to-server message of the RFB protocol.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage`1.GetParametersOverview">
            <summary>
            Returns a string which gives a short overview of the message parameters for logging purposes.
            </summary>
            <returns>A string with the message parameters or null, if there aren't any.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType">
            <summary>
            Represents a client-to-server message type of the RFB protocol.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType.WriteToTransport(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessageType},MarcusW.VncClient.Protocol.ITransport,System.Threading.CancellationToken)">
            <summary>
            Writes the <see cref="!:message"/> (including the message header) to the transport stream.
            </summary>
            <param name="message">The message to write.</param>
            <param name="transport">The target transport.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.MessageTypes.WellKnownIncomingMessageType">
            <summary>
            The well known incoming message types and their IDs.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.MessageTypes.WellKnownOutgoingMessageType">
            <summary>
            The well known outgoing message types and their IDs.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.RfbConnectionContext">
            <summary>
            Holds multiple connection-related objects and acts as a central place to provide the protocol implementation classes access to them.
            </summary>
            <remarks>
            This is just a container class that does not implement any complex logic.
            Remember that some of the properties might be uninitialized during early stages of the protocol.
            </remarks>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.Connection">
            <summary>
            Gets the <see cref="T:MarcusW.VncClient.RfbConnection"/> to which this connection belongs to.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetails">
            <summary>
            Gets a <see cref="T:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor"/> which provides write access to some details properties on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.State">
            <summary>
            Gets the protocol state object.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.SupportedSecurityTypes">
            <summary>
            Gets the security types that are supported by the client.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.SupportedMessageTypes">
            <summary>
            Gets the message types that are supported by the client.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.SupportedEncodingTypes">
            <summary>
            Gets the encoding types that are supported by the client.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.Transport">
            <summary>
            Gets the current transport layer used by the protocol.
            Please note, that this might be replaced with tunnel transports during the handshake procedure.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.MessageReceiver">
            <summary>
            Gets the <see cref="T:MarcusW.VncClient.Protocol.Services.IRfbMessageReceiver"/> for this connection.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.MessageSender">
            <summary>
            Gets the <see cref="T:MarcusW.VncClient.Protocol.Services.IRfbMessageSender"/> for this connection.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.ZLibInflater">
            <summary>
            Gets the <see cref="T:MarcusW.VncClient.Protocol.Services.IZLibInflater"/> for this connection.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.RfbConnectionContext.JpegDecoder">
            <summary>
            Gets the <see cref="T:MarcusW.VncClient.Protocol.Services.IJpegDecoder"/> for this connection.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.GetState``1">
            <summary>
            Casts the state object to <typeparam name="TState"/> and returns it.
            </summary>
            <typeparam name="TState">The type of the state object that implements <see cref="T:MarcusW.VncClient.Protocol.IRfbProtocolState"/>.</typeparam>
            <returns>The casted state.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor">
            <summary>
            Provides the protocol implementation classes with write access to some details properties of the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetProtocolVersion(MarcusW.VncClient.Protocol.RfbProtocolVersion)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.ProtocolVersion"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="protocolVersion">The new protocol version value.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetUsedSecurityType(MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.UsedSecurityType"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="usedSecurityType">The new security type.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetUsedMessageTypes(System.Collections.Immutable.IImmutableSet{MarcusW.VncClient.Protocol.MessageTypes.IMessageType})">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="usedMessageTypes">The new message types set.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetUsedEncodingTypes(System.Collections.Immutable.IImmutableSet{MarcusW.VncClient.Protocol.EncodingTypes.IEncodingType})">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.UsedEncodingTypes"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="usedEncodingTypes">The new encoding types set.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetRemoteFramebufferSize(MarcusW.VncClient.Size)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.RemoteFramebufferSize"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="remoteFramebufferSize">The new framebuffer size.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetRemoteFramebufferFormat(MarcusW.VncClient.PixelFormat)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.RemoteFramebufferFormat"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="remoteFramebufferFormat">The new framebuffer format.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetRemoteFramebufferLayout(System.Collections.Immutable.IImmutableSet{MarcusW.VncClient.Screen})">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.RemoteFramebufferLayout"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="remoteFramebufferLayout">The new framebuffer layout.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetDesktopName(System.String)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.DesktopName"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="desktopName">The new desktop name.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetDesktopIsResizable(System.Boolean)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.DesktopIsResizable"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="desktopIsResizable">The new state.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbConnectionContext.ConnectionDetailsAccessor.SetContinuousUpdatesEnabled(System.Boolean)">
            <summary>
            Sets the value of the <seealso cref="P:MarcusW.VncClient.RfbConnection.ContinuousUpdatesEnabled"/> property on the <see cref="T:MarcusW.VncClient.RfbConnection"/> object.
            </summary>
            <param name="continuousUpdatesEnabled">The new state.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.RfbProtocolVersion">
            <summary>
            The different versions of the RFB protocol.
            </summary>
            <remarks>
            See: https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#protocolversion
            </remarks>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.RfbProtocolVersion.Unknown">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.RfbProtocolVersion.RFB_3_3">
            <summary>
            RFB 3.3
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.RfbProtocolVersion.RFB_3_7">
            <summary>
            RFB 3.7
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.RfbProtocolVersion.RFB_3_8">
            <summary>
            RFB 3.8
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.RfbProtocolVersions">
            <summary>
            Helper methods for <see cref="T:MarcusW.VncClient.Protocol.RfbProtocolVersion"/>.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Protocol.RfbProtocolVersions.LatestSupported">
            <summary>
            The latest supported protocol version.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbProtocolVersions.GetFromStringRepresentation(System.String)">
            <summary>
            Returns the protocol version for the provided string representation.
            </summary>
            <param name="protocolVersionString">The protocol version string.</param>
            <returns>The <see cref="T:MarcusW.VncClient.Protocol.RfbProtocolVersion"/> or Unknown for invalid input strings.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.RfbProtocolVersionExtensions">
            <summary>
            Extension methods for <see cref="T:MarcusW.VncClient.Protocol.RfbProtocolVersion"/>.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbProtocolVersionExtensions.GetStringRepresentation(MarcusW.VncClient.Protocol.RfbProtocolVersion)">
            <summary>
            Returns the string representation of a given protocol version.
            </summary>
            <param name="protocolVersion">The protocol version.</param>
            <returns>The string representation defined by the protocol.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.RfbProtocolVersionExtensions.ToReadableString(MarcusW.VncClient.Protocol.RfbProtocolVersion)">
            <summary>
            Returns a readable string for a given protocol version.
            </summary>
            <param name="protocolVersion">The protocol version.</param>
            <returns>A readable string.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.SecurityTypes.AuthenticationResult">
            <summary>
            Provides information about the outcome of a security type authentication attempt.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.SecurityTypes.AuthenticationResult.TunnelTransport">
            <summary>
            Gets the established tunnel transport that will replace the base transport from now on.
            This is <see langword="null"/> when no tunnel was built.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.SecurityTypes.AuthenticationResult.ExpectSecurityResult">
            <summary>
            Gets whether the server will send a SecurityResult message after authentication.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.SecurityTypes.AuthenticationResult.#ctor(MarcusW.VncClient.Protocol.ITransport,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Protocol.SecurityTypes.AuthenticationResult"/>.
            </summary>
            <param name="tunnelTransport">The tunnel transport to replace the base transport with or <see langword="null"/> when no tunnel was built.</param>
            <param name="expectSecurityResult">True if the server will send a SecurityResult message after authentication, False otherwise.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType">
            <summary>
            Represents a RFB protocol security type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType.Id">
            <summary>
            Gets the ID for this security type.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType.Name">
            <summary>
            Gets a human readable name for this security type.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType.Priority" -->
        <member name="M:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType.AuthenticateAsync(MarcusW.VncClient.Security.IAuthenticationHandler,System.Threading.CancellationToken)">
            <summary>
            Executes the security type authentication.
            </summary>
            <param name="authenticationHandler">The authentication handler to request login data from the application.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The authentication result.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType.ReadServerInitExtensionAsync(System.Threading.CancellationToken)">
            <summary>
            Reads additional security type specific data contained in the ServerInit message after the main part has been read.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.SecurityTypes.WellKnownSecurityType">
            <summary>
            The well known security types and their IDs.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.IJpegDecoder">
            <summary>
            Provides methods for decoding JPEG images.
            </summary>
            <remarks>
            It's not necessary that implementations of this interface are thread-safe because the processing of received frames always happens synchronously in a single thread.
            Because of this, calls to methods of such implementations should never come from multiple threads.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IJpegDecoder.DecodeJpegTo32Bit(System.Span{System.Byte},System.Span{System.Byte},System.Int32,System.Int32,MarcusW.VncClient.PixelFormat,MarcusW.VncClient.PixelFormat@,System.Threading.CancellationToken)">
            <summary>
            Decompresses a JPEG encoded image to a 32bit <see cref="!:pixelsBuffer"/>.
            </summary>
            <param name="jpegBuffer">The compressed data.</param>
            <param name="pixelsBuffer">The 32bit target buffer.</param>
            <param name="expectedWidth">The expected width of the decompressed image.</param>
            <param name="expectedHeight">The expected height of the decompressed image.</param>
            <param name="preferredPixelFormat">The preferred 32bit target pixel format.</param>
            <param name="usedPixelFormat">The pixel format that was chosen for the pixels written to the <see cref="!:pixelsBuffer"/>.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.IRfbHandshaker">
            <summary>
            Provides methods for doing a RFB compliant handshake.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbHandshaker.DoHandshakeAsync(System.Threading.CancellationToken)">
            <summary>
            Executes a handshake.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The new built tunnel transport, otherwise null.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.IRfbInitializer">
            <summary>
            Provides methods for doing a RFB compliant initialization.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbInitializer.InitializeAsync(System.Threading.CancellationToken)">
            <summary>
            Executes a initialization.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.IRfbMessageReceiver">
            <summary>
            Describes a background thread that receives and processes RFB protocol messages.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageReceiver.StartReceiveLoop">
            <summary>
            Starts the receive loop.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageReceiver.StopReceiveLoopAsync">
            <summary>
            Stops the receive loop and waits for completion.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.IRfbMessageSender">
            <summary>
            Describes a background thread that sends queued messages and provides methods to add messages to the send queue.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageSender.StartSendLoop">
            <summary>
            Starts the send loop.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageSender.StopSendLoopAsync">
            <summary>
            Stops the send loop and waits for completion.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageSender.EnqueueInitialMessages(System.Threading.CancellationToken)">
            <summary>
            Enqueues some initial messages to get things rolling.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageSender.EnqueueMessage``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <summary>
            Adds the <paramref name="message"/> to the send queue and returns without waiting for it being sent.
            </summary>
            <param name="message">The message to send.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <typeparam name="TMessageType">The type of the message.</typeparam>
            <remarks>Please ensure the outgoing message type is marked as being supported by both sides before sending it. See <see cref="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes"/>.</remarks>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageSender.SendMessageAndWait``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <summary>
            Adds the <paramref name="message"/> to the send queue and waits synchronously for the message being sent.
            </summary>
            <param name="message">The message to send.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <typeparam name="TMessageType">The type of the message.</typeparam>
            <remarks>Please ensure the outgoing message type is marked as being supported by both sides before sending it. See <see cref="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes"/>.</remarks>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IRfbMessageSender.SendMessageAndWaitAsync``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <summary>
            Adds the <paramref name="message"/> to the send queue and returns a <see cref="T:System.Threading.Tasks.Task"/> that completes when the message was sent.
            </summary>
            <param name="message">The message to send.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <typeparam name="TMessageType">The type of the message.</typeparam>
            <remarks>Please ensure the outgoing message type is marked as being supported by both sides before sending it. See <see cref="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes"/>.</remarks>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.ITransportConnector">
            <summary>
            Provides methods for establishing transport connections used for the RFB protocol.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.ITransportConnector.ConnectAsync(System.Threading.CancellationToken)">
            <summary>
            Connects to the specified endpoint and returns the resulting <see cref="T:MarcusW.VncClient.Protocol.ITransport"/>.
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The open transport.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Protocol.Services.IZLibInflater">
            <summary>
            Provides methods for inflating (decompressing) received data using per-connection zlib streams.
            </summary>
            <remarks>
            It's not necessary that implementations of this interface are thread-safe because the processing of received frames always happens synchronously in a single thread.
            Because of this, calls to methods of such implementations should never come from multiple threads.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IZLibInflater.ReadAndInflate(System.IO.Stream,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>
            Reads <paramref name="sourceLength"/> bytes from the <paramref name="source"/> stream and returns a stream for inflating them.
            </summary>
            <remarks>For optimization reasons, this method must not be called again before the reading from the returned stream is over.</remarks>
            <param name="source">The stream to read the deflated bytes from.</param>
            <param name="sourceLength">The length of the deflated sector in the source stream.</param>
            <param name="zlibStreamId">The zlib stream to be used for inflating or <c>-1</c> to select the default stream.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The inflating stream.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Protocol.Services.IZLibInflater.ResetZlibStream(System.Int32)">
            <summary>
            Resets the zlib stream for the given selector.
            </summary>
            <param name="id">The zlib stream to reset.</param>
        </member>
        <member name="T:MarcusW.VncClient.Rectangle">
            <summary>
            Represents a rectangle of a given <see cref="P:MarcusW.VncClient.Rectangle.Position"/> and <see cref="P:MarcusW.VncClient.Rectangle.Size"/>.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Rectangle.Zero">
            <summary>
            A rectangle with the size zero at the origin of the coordinate system.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rectangle.Position">
            <summary>
            Gets the position of the upper left corner of the rectangle.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rectangle.Size">
            <summary>
            Gets the size of the rectangle.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.#ctor(MarcusW.VncClient.Position,MarcusW.VncClient.Size)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Rectangle"/> structure.
            </summary>
            <param name="position">The position of the upper left corner of the rectangle.</param>
            <param name="size">The size of the rectangle.</param>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Rectangle"/> structure.
            </summary>
            <param name="x">The x coordinate of the upper left corner of the rectangle.</param>
            <param name="y">The y coordinate of the upper left corner of the rectangle.</param>
            <param name="width">The width of the rectangle.</param>
            <param name="height">The height of the rectangle.</param>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.op_Equality(MarcusW.VncClient.Rectangle,MarcusW.VncClient.Rectangle)">
            <summary>
            Checks for equality between two <see cref="T:MarcusW.VncClient.Rectangle"/>s.
            </summary>
            <param name="left">The first rectangle.</param>
            <param name="right">The second rectangle.</param>
            <returns>True if the rectangles are equal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.op_Inequality(MarcusW.VncClient.Rectangle,MarcusW.VncClient.Rectangle)">
            <summary>
            Checks for inequality between two <see cref="T:MarcusW.VncClient.Rectangle"/>s.
            </summary>
            <param name="left">The first rectangle.</param>
            <param name="right">The second rectangle.</param>
            <returns>True if the rectangles are unequal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.Equals(MarcusW.VncClient.Rectangle)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.WithPosition(MarcusW.VncClient.Position)">
            <summary>
            Returns a new <see cref="T:MarcusW.VncClient.Rectangle"/> with the specified position.
            </summary>
            <param name="position">The position.</param>
            <returns>A new rectangle.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.WithSize(MarcusW.VncClient.Size)">
            <summary>
            Returns a new <see cref="T:MarcusW.VncClient.Rectangle"/> with the specified size.
            </summary>
            <param name="size">The size.</param>
            <returns>A new rectangle.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.IsEmpty">
            <summary>
            Returns whether this rectangle has no content (one side is zero)
            </summary>
            <returns>True if it has no content, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.FitsInside(MarcusW.VncClient.Size@)">
            <summary>
            Returns whether this rectangle completely fits inside an area in the origin with the given size.
            </summary>
            <param name="areaSize">The size of the area in which the rectangle should fit in.</param>
            <returns>True if it fits inside, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.FitsInside(MarcusW.VncClient.Rectangle@)">
            <summary>
            Returns whether this rectangle completely fits inside the given area.
            </summary>
            <param name="area">The area in which the rectangle should fit in.</param>
            <returns>True if it fits inside, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.Overlaps(MarcusW.VncClient.Rectangle@)">
            <summary>
            Returns whether this rectangle overlaps the given area.
            </summary>
            <param name="area">The area to test for.</param>
            <returns>True if they overlap, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.CroppedTo(MarcusW.VncClient.Rectangle@)">
            <summary>
            Returns a new <see cref="T:MarcusW.VncClient.Rectangle"/> that is reduced enough to make it fit inside the given area.
            </summary>
            <param name="area">The area in which the rectangle should fit in.</param>
            <returns>A new rectangle.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Rectangle.ToString">
            <summary>
            Returns the string representation of the rectangle.
            </summary>
            <returns>The string representation of the rectangle.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Rendering.IFramebufferReference">
            <summary>
            A reference to the native framebuffer of the target device. Should be disposed after rendering is finished.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rendering.IFramebufferReference.Address">
            <summary>
            Gets the address of the first pixel.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rendering.IFramebufferReference.Size">
            <summary>
            Gets the framebuffer size in device pixels.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rendering.IFramebufferReference.Format">
            <summary>
            Gets the format of how the pixels are represented in memory.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rendering.IFramebufferReference.HorizontalDpi">
            <summary>
            Gets the horizontal DPI of the underlying screen.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Rendering.IFramebufferReference.VerticalDpi">
            <summary>
            Gets the vertical DPI of the underlying screen.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Rendering.IRenderTarget">
            <summary>
            Provides access to a target framebuffer for rendering frames.
            </summary>
            <remarks>
            This is an abstraction around the different framebuffer access methods for rendering backends like Avalonia (Skia, Direct2D, ...), WPF and others.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.Rendering.IRenderTarget.GrabFramebufferReference(MarcusW.VncClient.Size,System.Collections.Immutable.IImmutableSet{MarcusW.VncClient.Screen})">
            <summary>
            Locks the native framebuffer in memory and returns a reference to it. The returned object should be disposed after rendering is finished.
            Must only be used by one thread at a time.
            The framebuffer should be re-created in case the <paramref name="size"/> changes.
            </summary>
            <param name="size">The required frame size.</param>
            <param name="layout">The screens that are contained by the frame (if supported).</param>
            <returns>The framebuffer reference.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Rendering.RenderFlags">
            <summary>
            Some flags to control how rendering to the target framebuffer should happen.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Rendering.RenderFlags.Default">
            <summary>
            The default.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Rendering.RenderFlags.UpdateByRectangle">
            <summary>
            If set, the screen will be updated by received rectangle instead of by frame.
            This might improve display latency for the cost of screen tearing and some overhead.
            </summary>
        </member>
        <member name="F:MarcusW.VncClient.Rendering.RenderFlags.VisualizeRectangles">
            <summary>
            If set, the rendered rectangles and the used encoding type will be visualized for debugging purposes.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.RfbConnection">
            <summary>
            Connection with a remote server using the RFB protocol.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.ProtocolImplementation">
            <summary>
            Gets the used RFB protocol implementation.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.LoggerFactory">
            <summary>
            Gets the logger factory implementation that should be used for creating new loggers.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.Parameters">
            <summary>
            Gets the connect parameters used for establishing this connection.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.RenderTarget">
            <summary>
            Gets or sets the target where received frames should be rendered to.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.OutputHandler">
            <summary>
            Gets or sets the handler for output events from the server.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.InterruptionCause">
            <summary>
            Gets the <see cref="T:System.Exception"/> that caused the last connection interruption.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.ConnectionState">
            <summary>
            Gets the current connection state. Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="E:MarcusW.VncClient.RfbConnection.PropertyChanged">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.RfbConnection.CloseAsync">
            <summary>
            Closes the running remote connection as well as any running reconnect attempts.
            </summary>
            <remarks>
            To cancel the connection establishment, use the <see cref="T:System.Threading.CancellationToken"/> passed to <see cref="M:MarcusW.VncClient.RfbConnection.StartAsync(System.Threading.CancellationToken)"/> instead.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.RfbConnection.Dispose">
            <inheritdoc />
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.ProtocolVersion">
            <summary>
            Gets the version of the protocol used for remote communication.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.UsedSecurityType">
            <summary>
            Gets the security type that was used for authenticating and securing the connection.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes">
            <summary>
            Gets the message types that are currently used by this connection.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.UsedEncodingTypes">
            <summary>
            Gets the encoding types that are currently used by this connection.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.RemoteFramebufferSize">
            <summary>
            Gets the current size of the remote view.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.RemoteFramebufferFormat">
            <summary>
            Gets the current format of the remote view.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.RemoteFramebufferLayout">
            <summary>
            Gets the current layout of the remote view.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.DesktopName">
            <summary>
            Gets the current name of the remote desktop.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.DesktopIsResizable">
            <summary>
            Gets whether the connection allows client-side desktop size changes.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.RfbConnection.ContinuousUpdatesEnabled">
            <summary>
            Gets the current state of the continuous update protocol feature.
            Subscribe to <see cref="E:MarcusW.VncClient.RfbConnection.PropertyChanged"/> to receive change notifications.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.RfbConnection.EnqueueMessage``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <summary>
            Adds the <paramref name="message"/> to the send queue and returns without waiting for it being sent.
            </summary>
            <param name="message">The message to send.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <typeparam name="TMessageType">The type of the message.</typeparam>
            <returns>True, if the message was queued, otherwise false.</returns>
            <remarks>Please ensure the outgoing message type is marked as being supported by both sides before sending it. See <see cref="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes"/>.</remarks>
        </member>
        <member name="M:MarcusW.VncClient.RfbConnection.SendMessageAsync``1(MarcusW.VncClient.Protocol.MessageTypes.IOutgoingMessage{``0},System.Threading.CancellationToken)">
            <summary>
            Adds the <paramref name="message"/> to the send queue and returns a <see cref="T:System.Threading.Tasks.Task"/> that completes when the message was sent.
            </summary>
            <param name="message">The message to send.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <typeparam name="TMessageType">The type of the message.</typeparam>
            <remarks>Please ensure the outgoing message type is marked as being supported by both sides before sending it. See <see cref="P:MarcusW.VncClient.RfbConnection.UsedMessageTypes"/>.</remarks>
        </member>
        <member name="T:MarcusW.VncClient.Screen">
            <summary>
            Represents a screen as part of a remote framebuffer.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Screen.Id">
            <summary>
            Gets the screen id.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Screen.Rectangle">
            <summary>
            Gets the rectangle of the screen on the framebuffer.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Screen.Flags">
            <summary>
            Gets the flags.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Screen.#ctor(System.UInt32,MarcusW.VncClient.Rectangle,System.UInt32)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Screen"/> structure.
            </summary>
            <param name="id">The screen id.</param>
            <param name="position">The rectangle of the screen on the framebuffer.</param>
            <param name="flags">The flags.</param>
        </member>
        <member name="M:MarcusW.VncClient.Screen.op_Equality(MarcusW.VncClient.Screen,MarcusW.VncClient.Screen)">
            <summary>
            Checks for equality between two <see cref="T:MarcusW.VncClient.Screen"/>s.
            </summary>
            <param name="left">The first screen.</param>
            <param name="right">The second screen.</param>
            <returns>True if the screens are equal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Screen.op_Inequality(MarcusW.VncClient.Screen,MarcusW.VncClient.Screen)">
            <summary>
            Checks for inequality between two <see cref="T:MarcusW.VncClient.Screen"/>s.
            </summary>
            <param name="left">The first screen.</param>
            <param name="right">The second screen.</param>
            <returns>True if the screens are unequal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Screen.Equals(MarcusW.VncClient.Screen)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Screen.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Screen.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Screen.ToString">
            <summary>
            Returns the string representation of the screen.
            </summary>
            <returns>The string representation of the screen.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Security.IAuthenticationHandler">
            <summary>
            Provides handlers for authentication requests.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Security.IAuthenticationHandler.ProvideAuthenticationInputAsync``1(MarcusW.VncClient.RfbConnection,MarcusW.VncClient.Protocol.SecurityTypes.ISecurityType,MarcusW.VncClient.Security.IAuthenticationInputRequest{``0})">
            <summary>
            Handles an authentication input request and tries to get the requested data from the user or device.
            </summary>
            <param name="connection">The connection which this request belongs to.</param>
            <param name="securityType">The security type which raised the request.</param>
            <param name="request">The input request.</param>
            <typeparam name="TInput">The type of the requested input.</typeparam>
            <returns>The input response.</returns>
        </member>
        <member name="T:MarcusW.VncClient.Security.IAuthenticationInput">
            <summary>
            Represents a response for a <see cref="!:IAuthenticationInputRequest"/>.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Security.IAuthenticationInputRequest`1">
            <summary>
            Represents a request for input data needed for authentication.
            </summary>
            <typeparam name="TInput">The type of the requested input.</typeparam>
        </member>
        <member name="T:MarcusW.VncClient.Security.PasswordAuthenticationInput">
            <summary>
            Contains the input data that was requested for a password authentication.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Security.PasswordAuthenticationInput.Password">
            <summary>
            Gets the requested password.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Security.PasswordAuthenticationInput.#ctor(System.String)">
            <summary>
            Initializes a new instance of <see cref="T:MarcusW.VncClient.Security.PasswordAuthenticationInput"/>.
            </summary>
            <param name="password">The requested password.</param>
        </member>
        <member name="T:MarcusW.VncClient.Security.PasswordAuthenticationInputRequest">
            <summary>
            An input request for password authentication.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.Size">
            <summary>
            Represents a size in device pixels.
            </summary>
            <remarks>
            Based on https://github.com/AvaloniaUI/Avalonia/blob/master/src/Avalonia.Visuals/Media/PixelSize.cs
            </remarks>
        </member>
        <member name="F:MarcusW.VncClient.Size.Zero">
            <summary>
            A size representing zero.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Size.Width">
            <summary>
            Gets the width.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Size.Height">
            <summary>
            Gets the height.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Size.AspectRatio">
            <summary>
            Gets the aspect ratio of the size.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Size.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Size"/> structure.
            </summary>
            <param name="width">The width.</param>
            <param name="height">The height.</param>
        </member>
        <member name="M:MarcusW.VncClient.Size.op_Equality(MarcusW.VncClient.Size,MarcusW.VncClient.Size)">
            <summary>
            Checks for equality between two <see cref="T:MarcusW.VncClient.Size"/>s.
            </summary>
            <param name="left">The first size.</param>
            <param name="right">The second size.</param>
            <returns>True if the sizes are equal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.op_Inequality(MarcusW.VncClient.Size,MarcusW.VncClient.Size)">
            <summary>
            Checks for inequality between two <see cref="T:MarcusW.VncClient.Size"/>s.
            </summary>
            <param name="left">The first size.</param>
            <param name="right">The second size.</param>
            <returns>True if the sizes are unequal, otherwise false.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.Equals(MarcusW.VncClient.Size)">
            <summary>
            Returns a boolean indicating whether the size is equal to the other given size.
            </summary>
            <param name="other">The other size to test equality against.</param>
            <returns>True if this size is equal to other, False otherwise.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.Equals(System.Object)">
            <summary>
            Checks for equality between a size and an object.
            </summary>
            <param name="obj">The object.</param>
            <returns>
            True if <paramref name="obj"/> is a size that equals the current size.
            </returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.GetHashCode">
            <summary>
            Returns a hash code for a <see cref="T:MarcusW.VncClient.Size"/>.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.WithWidth(System.Int32)">
            <summary>
            Returns a new <see cref="T:MarcusW.VncClient.Size"/> with the same height and the specified width.
            </summary>
            <param name="width">The width.</param>
            <returns>The new <see cref="T:MarcusW.VncClient.Size"/>.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.WithHeight(System.Int32)">
            <summary>
            Returns a new <see cref="T:MarcusW.VncClient.Size"/> with the same width and the specified height.
            </summary>
            <param name="height">The height.</param>
            <returns>The new <see cref="T:MarcusW.VncClient.Size"/>.</returns>
        </member>
        <member name="M:MarcusW.VncClient.Size.ToString">
            <summary>
            Returns the string representation of the size.
            </summary>
            <returns>The string representation of the size.</returns>
        </member>
        <member name="T:MarcusW.VncClient.TransportParameters">
            <summary>
            Represents parameters for establishing a RFB transport.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.TransportParameters.ToString">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Utils.BackgroundThread">
            <summary>
            Base class for easier creation and clean cancellation of a background thread.
            </summary>
        </member>
        <member name="E:MarcusW.VncClient.Utils.BackgroundThread.Failed">
            <inheritdoc />
        </member>
        <member name="M:MarcusW.VncClient.Utils.BackgroundThread.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Utils.BackgroundThread"/>.
            </summary>
            <param name="name">The thread name.</param>
        </member>
        <member name="M:MarcusW.VncClient.Utils.BackgroundThread.Start">
            <summary>
            Starts the thread.
            </summary>
            <remarks>
            The thread can only be started once.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.Utils.BackgroundThread.StopAndWaitAsync">
            <summary>
            Stops the thread and waits for completion.
            </summary>
            <remarks>
            It is safe to call this method multiple times.
            </remarks>
        </member>
        <member name="M:MarcusW.VncClient.Utils.BackgroundThread.ThreadWorker(System.Threading.CancellationToken)">
            <summary>
            Executes the work that should happen in the background.
            </summary>
            <param name="cancellationToken">The cancellation token that tells the method implementation when to complete.</param>
        </member>
        <member name="M:MarcusW.VncClient.Utils.BackgroundThread.Dispose">
            <inheritdoc />
        </member>
        <member name="T:MarcusW.VncClient.Utils.BackgroundThreadFailedEventArgs">
            <summary>
            Provides data for an event that is raised when a background thread failes.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Utils.BackgroundThreadFailedEventArgs.Exception">
            <summary>
            Gets the exception that describes the failure.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.BackgroundThreadFailedEventArgs.#ctor(System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.Utils.BackgroundThreadFailedEventArgs"/>.
            </summary>
            <param name="exception">The exception that describes the failure.</param>
        </member>
        <member name="T:MarcusW.VncClient.Utils.FreezableParametersObject">
            <summary>
            Represents a parameters object that can be made immutable.
            </summary>
        </member>
        <member name="P:MarcusW.VncClient.Utils.FreezableParametersObject.IsFrozen">
            <summary>
            Gets whether this object is frozen.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.FreezableParametersObject.Validate">
            <summary>
            Validates the parameters of this object and throws a <see cref="T:MarcusW.VncClient.ConnectParametersValidationException"/> for the first error found.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.FreezableParametersObject.GetDescendants">
            <summary>
            Returns all referenced <see cref="T:MarcusW.VncClient.Utils.FreezableParametersObject"/> descendants of this object or <see langword="null"/>, when there aren't any.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.FreezableParametersObject.ValidateRecursively">
            <summary>
            Validates the parameters of this object and all descendants and throws a <see cref="T:MarcusW.VncClient.ConnectParametersValidationException"/> for the first error found.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.FreezableParametersObject.ValidateAndFreezeRecursively">
            <summary>
            Validates this object and all descendants and makes them immutable in case the validation succeeded.
            When this happens, all following write operations will fail.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.FreezableParametersObject.ThrowIfFrozen">
            <summary>
            Throws a <see cref="T:System.InvalidOperationException"/> if this object is frozen.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.Utils.FreezableParametersObject.ThrowIfFrozen(System.Action)">
            <summary>
            Throws a <see cref="T:System.InvalidOperationException"/> if this object is frozen, otherwise <paramref name="action"/> is executed.
            </summary>
            <param name="action">The action to execute, if the object was not frozen.</param>
        </member>
        <member name="T:MarcusW.VncClient.Utils.IBackgroundThread">
            <summary>
            Describes a background thread.
            </summary>
        </member>
        <member name="E:MarcusW.VncClient.Utils.IBackgroundThread.Failed">
            <summary>
            Occurs when the background thread fails.
            </summary>
        </member>
        <member name="T:MarcusW.VncClient.VncClient">
            <summary>
            Client for the RFB protocol which allows connecting to remote VNC servers.
            </summary>
        </member>
        <member name="M:MarcusW.VncClient.VncClient.#ctor(Microsoft.Extensions.Logging.ILoggerFactory)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.VncClient"/>.
            </summary>
            <param name="loggerFactory">The logger factory implementation that should be used for creating new loggers.</param>
        </member>
        <member name="M:MarcusW.VncClient.VncClient.#ctor(Microsoft.Extensions.Logging.ILoggerFactory,MarcusW.VncClient.Protocol.IRfbProtocolImplementation)">
            <summary>
            Initializes a new instance of the <see cref="T:MarcusW.VncClient.VncClient"/>.
            </summary>
            <param name="loggerFactory">The logger factory implementation that should be used for creating new loggers.</param>
            <param name="protocolImplementation">The <see cref="T:MarcusW.VncClient.Protocol.IRfbProtocolImplementation"/> that should be used.</param>
        </member>
        <member name="M:MarcusW.VncClient.VncClient.ConnectAsync(MarcusW.VncClient.ConnectParameters,System.Threading.CancellationToken)">
            <summary>
            Tries to connect to a VNC server and initializes a new connection object.
            </summary>
            <param name="parameters">The connect parameters.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>An initialized <see cref="T:MarcusW.VncClient.RfbConnection"/> instance.</returns>
        </member>
    </members>
</doc>
